4c4
<    Copyright (C) 2013-2014, 2016, 2018-2020 Genome Research Ltd.
---
>    Copyright (C) 2013-2014, 2016, 2018-2019 Genome Research Ltd.
27,28c27,31
< import core.stdc.config;
< import core.stdc.stdio;
---
> module htslib.kstring;
> 
> import core.stdc.config : c_long;
> import core.stdc.stdarg;
> import core.stdc.stdio : EOF;
29a33,35
> import core.stdc.string : memcpy, strlen;
> 
> alias ssize_t = ptrdiff_t;	// should be defined in core.stdc somewhere but is not :/
33c39
< // __MINGW_PRINTF_FORMAT
---
> // #define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
35c41,74
< enum HAVE___BUILTIN_CLZ = 1;
---
> /// round 32 or 64 bit (u)int x to power of 2 that is equal or greater (JSB)
> pragma(inline, true)
> extern (D)
> void kroundup_size_t(ref size_t x) {
> 	x -= 1;
> 	x |= (x >> 1);
> 	x |= (x >> 2);
> 	x |= (x >> 4);
> 	x |= (x >> 8);
> 	x |= (x >> 16);
> 
> 	static if (size_t.sizeof == 8)
>         x |= (x >> 32);
> 
> 	++x;
> }
> 
> /+
> #if defined __GNUC__ && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
> #ifdef __MINGW_PRINTF_FORMAT
> #define KS_ATTR_PRINTF(fmt, arg) __attribute__((__format__ (__MINGW_PRINTF_FORMAT, fmt, arg)))
> #else
> #define KS_ATTR_PRINTF(fmt, arg) __attribute__((__format__ (__printf__, fmt, arg)))
> #endif // __MINGW_PRINTF_FORMAT
> #else
> #define KS_ATTR_PRINTF(fmt, arg)
> #endif
> 
> #ifndef HAVE___BUILTIN_CLZ
> #if defined __GNUC__ && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
> #define HAVE___BUILTIN_CLZ 1
> #endif
> #endif
> +/
63c102
< int kvsprintf (kstring_t* s, const(char)* fmt, va_list ap);
---
> int kvsprintf(kstring_t* s, const(char)* fmt, va_list ap);
65c104
< int ksprintf (kstring_t* s, const(char)* fmt, ...);
---
> int ksprintf(kstring_t* s, const(char)* fmt, ...);
67c106
< int kputd (double d, kstring_t* s); // custom %g only handler
---
> int kputd(double d, kstring_t* s); // custom %g only handler
69c108
< int ksplit_core (char* s, int delimiter, int* _max, int** _offsets);
---
> int ksplit_core(char* s, int delimiter, int* _max, int** _offsets);
71c110
< char* kstrstr (const(char)* str, const(char)* pat, int** _prep);
---
> char* kstrstr(const(char)* str, const(char)* pat, int** _prep);
73c112
< char* kstrnstr (const(char)* str, const(char)* pat, int n, int** _prep);
---
> char* kstrnstr(const(char)* str, const(char)* pat, int n, int** _prep);
75c114
< void* kmemmem (const(void)* _str, int n, const(void)* _pat, int m, int** _prep);
---
> void* kmemmem(const(void)* _str, int n, const(void)* _pat, int m, int** _prep);
81c120
< char* kstrtok (const(char)* str, const(char)* sep, ks_tokaux_t* aux);
---
> char* kstrtok(const(char)* str, const(char)* sep, ks_tokaux_t* aux);
84,95c123,131
<  * or "\r\n"-terminated line from fp.  The line read is appended to the
<  * kstring without its terminator and 0 is returned; EOF is returned at
<  * EOF or on error (determined by querying fp, as per fgets()). */
< alias kgets_func = char* function (char*, int, void*);
< int kgetline (kstring_t* s, char* function () fgets_fn, void* fp);
< 
< /* kgetline2() uses the supplied hgetln()-like function to read a "\n"-
<  * or "\r\n"-terminated line from fp.  The line read is appended to the
<  * ksring without its terminator and 0 is returned; EOF is returned at
<  * EOF or on error (determined by querying fp, as per fgets()). */
< alias kgets_func2 = c_long function (char*, size_t, void*);
< int kgetline2 (kstring_t* s, ssize_t function () fgets_fn, void* fp);
---
> 	 * or "\r\n"-terminated line from fp.  The line read is appended to the
> 	 * kstring without its terminator and 0 is returned; EOF is returned at
> 	 * EOF or on error (determined by querying fp, as per fgets()). */
> alias kgets_func = char* function(char*, int, void*);
> int kgetline(kstring_t* s, char* function(char*, int, void*) fgets, void* fp);
> 
> // This matches the signature of hgetln(), apart from the last pointer
> alias kgets_func2 = c_long function(char*, size_t, void*);
> int kgetline2(kstring_t* s, ssize_t function(char*, size_t, void*) fgets, void* fp);
97a134
> //#define KS_INITIALIZE { 0, 0, NULL }
105c142,146
< void ks_initialize (kstring_t* s);
---
> void ks_initialize(kstring_t* s)
> {
>     s.l = s.m = 0;
>     s.s = null;
> }
108c149,161
< int ks_resize (kstring_t* s, size_t size);
---
> int ks_resize(kstring_t* s, size_t size)
> {
> 	if (s.m < size) {
> 		char *tmp;
> 		kroundup_size_t(size);
> 		tmp = cast(char*)realloc(s.s, size);
> 		if (!tmp && size)
> 		    return -1;
> 		s.s = tmp;
> 		s.m = size;
> 	}
> 	return 0;
> }
110a164,166
> int ks_expand(kstring_t* s, size_t expansion)
> {
>     size_t new_size = s.l + expansion;
112,113c168,171
< // Overflow check
< int ks_expand (kstring_t* s, size_t expansion);
---
>     if (new_size < s.l) // Overflow check
>         return -1;
>     return ks_resize(s, new_size);
> }
116c174,177
< char* ks_str (kstring_t* s);
---
> char* ks_str(kstring_t* s)
> {
> 	return s.s;
> }
124c185,188
< const(char)* ks_c_str (kstring_t* s);
---
> const(char)* ks_c_str(kstring_t* s)
> {
>     return s.l && s.s ? s.s : "";
> }
126c190,193
< size_t ks_len (kstring_t* s);
---
> size_t ks_len(kstring_t* s)
> {
> 	return s.l;
> }
134c201,205
< kstring_t* ks_clear (kstring_t* s);
---
> kstring_t* ks_clear(kstring_t* s)
> {
>     s.l = 0;
>     return s;
> }
140c211,217
< char* ks_release (kstring_t* s);
---
> char* ks_release(kstring_t* s)
> {
> 	char *ss = s.s;
> 	s.l = s.m = 0;
> 	s.s = null;
> 	return ss;
> }
143,151c220,226
< void ks_free (kstring_t* s);
< 
< int kputsn (const(char)* p, size_t l, kstring_t* s);
< 
< int kputs (const(char)* p, kstring_t* s);
< 
< int kputc (int c, kstring_t* s);
< 
< int kputc_ (int c, kstring_t* s);
---
> void ks_free(kstring_t* s)
> {
>     if (s) {
>         free(s.s);
>         ks_initialize(s);
>     }
> }
153c228,237
< int kputsn_ (const(void)* p, size_t l, kstring_t* s);
---
> int kputsn(const(char)* p, size_t l, kstring_t* s)
> {
> 	size_t new_sz = s.l + l + 2;
> 	if (new_sz <= s.l || ks_resize(s, new_sz) < 0)
> 		return EOF;
> 	memcpy(s.s + s.l, p, l);
> 	s.l += l;
> 	s.s[s.l] = 0;
> 	return cast(int)l;	// no implicit down casting
> }
155c239,242
< // Trivial case - also prevents __builtin_clz(0), which is undefined
---
> int kputs(const(char)* p, kstring_t* s)
> {
> 	return kputsn(p, strlen(p), s);
> }
157c244,251
< // Find out how many digits are to be printed.
---
> int kputc(int c, kstring_t* s)
> {
> 	if (ks_resize(s, s.l + 2) < 0)
> 		return EOF;
> 	s.s[s.l++] = cast(char)c;	// no implicit down casting
> 	s.s[s.l] = 0;
> 	return cast(ubyte)c;
> }
159,166c253,259
< /*
<  * Table method - should be quick if clz can be done in hardware.
<  * Find the most significant bit of the value to print and look
<  * up in a table to find out how many decimal digits are needed.
<  * This number needs to be adjusted by 1 for cases where the decimal
<  * length could vary for a given number of bits (for example,
<  * a four bit number could be between 8 and 15).
<  */
---
> int kputc_(int c, kstring_t* s)
> {
> 	if (ks_resize(s, s.l + 1) < 0)
> 		return EOF;
> 	s.s[s.l++] = cast(char)c;	// no implicit down casting
> 	return 1;
> }
168c261,269
< // Fallback for when clz is not available
---
> int kputsn_(const(void)* p, size_t l, kstring_t* s)
> {
> 	size_t new_sz = s.l + l;
> 	if (new_sz < s.l || ks_resize(s, new_sz ? new_sz : 1) < 0)
> 		return EOF;
> 	memcpy(s.s + s.l, p, l);
> 	s.l += l;
> 	return cast(int)l;	// no implicit down casting
> }
170c271,358
< // Add digits two at a time
---
> // htslib 1.10 replaced this function with a higher performance
> // version using BSR/CTLZ intrinsics . this diverges from klib's
> // kstring implementation. other functions may have also changed.
> int kputuw(uint x, kstring_t* s){
> 	version(LDC){
> 		static uint[32] kputuw_num_digits = [
> 			10, 10, 10,  9,  9,  9,  8,  8,
> 			8,   7,  7,  7,  7,  6,  6,  6,
> 			5,   5,  5,  4,  4,  4,  4,  3,
> 			3,   3,  2,  2,  2,  1,  1,  1
> 		];
> 		static uint[32] kputuw_thresholds = [
> 			0,        0, 1000000000U, 0,       0, 100000000U,   0,      0,
> 			10000000, 0,          0,  0, 1000000,         0,    0, 100000,
> 			0,        0,      10000,  0,       0,         0, 1000,      0,
> 			0,      100,          0,  0,      10,         0,    0,      0
> 		];
> 	}else{
> 		ulong m;
> 	}
>     static string kputuw_dig2r =
>         "00010203040506070809" ~
>         "10111213141516171819" ~
>         "20212223242526272829" ~
>         "30313233343536373839" ~
>         "40414243444546474849" ~
>         "50515253545556575859" ~
>         "60616263646566676869" ~
>         "70717273747576777879" ~
>         "80818283848586878889" ~
>         "90919293949596979899";
>     uint l, j;
>     char * cp;
> 
>     // Trivial case - also prevents __builtin_clz(0), which is undefined
>     if (x < 10) {
>         if (ks_resize(s, s.l + 2) < 0)
>             return EOF;
>         s.s[s.l++] = cast(char)('0'+x);
>         s.s[s.l] = 0;
>         return 0;
>     }
> 
>     // Find out how many digits are to be printed.
> 	version(LDC){
> 			/*
> 		* Table method - should be quick if clz can be done in hardware.
> 		* Find the most significant bit of the value to print and look
> 		* up in a table to find out how many decimal digits are needed.
> 		* This number needs to be adjusted by 1 for cases where the decimal
> 		* length could vary for a given number of bits (for example,
> 		* a four bit number could be between 8 and 15).
> 		*/
> 		import ldc.intrinsics;
> 
> 		// ldc version of __builtin_clz
> 		l = llvm_ctlz(x,true);
> 		l = kputuw_num_digits[l] - (x < kputuw_thresholds[l]);
> 	}else{
> 	// Fallback for when clz is not available
> 		m = 1;
> 		l = 0;
> 		do {
> 			l++;
> 			m *= 10;
> 		} while (x >= m);
> 	}
> 
>     if (ks_resize(s, s.l + l + 2) < 0)
>         return EOF;
> 
>     // Add digits two at a time
>     j = l;
>     cp = s.s + s.l;
>     while (x >= 10) {
>         const char *d = &kputuw_dig2r[2*(x%100)];
>         x /= 100;
>         memcpy(&cp[j-=2], d, 2);
>     }
> 
>     // Last one (if necessary).  We know that x < 10 by now.
>     if (j == 1)
>         cp[0] = cast(char)(x + '0');
> 
>     s.l += l;
>     s.s[s.l] = 0;
>     return 0;
> }
172,173c360,368
< // Last one (if necessary).  We know that x < 10 by now.
< int kputuw (uint x, kstring_t* s);
---
> int kputw(int c, kstring_t* s)
> {
>     uint x = c;
>     if (c < 0) {
>         x = -x;
>         if (ks_resize(s, s.l + 3) < 0)
>             return EOF;
>         s.s[s.l++] = '-';
>     }
175c370,371
< int kputw (int c, kstring_t* s);
---
>     return kputuw(x, s);
> }
177c373,386
< int kputll (long c, kstring_t* s);
---
> int kputll(long c, kstring_t* s)
> {
> 	char[32] buf;
> 	int i, l = 0;
> 	ulong x = c;
> 	if (c < 0) x = -x;
> 	do { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);
> 	if (c < 0) buf[l++] = '-';
> 	if (ks_resize(s, s.l + l + 2) < 0)
> 		return EOF;
> 	for (i = l - 1; i >= 0; --i) s.s[s.l++] = buf[i];
> 	s.s[s.l] = 0;
> 	return 0;
> }
179c388,390
< int kputl (c_long c, kstring_t* s);
---
> int kputl(c_long c, kstring_t* s) {
>     return kputll(c, s);
> }
183c394
<  *         NULL on failure.
---
>  *         NULL on failue.
185c396,403
< int* ksplit (kstring_t* s, int delimiter, int* n);
---
> int* ksplit(kstring_t* s, int delimiter, int* n)
> {
> 	int max = 0;
> 	int* offsets = null;
> 	*n = ksplit_core(s.s, delimiter, &max, &offsets);
> 	return offsets;
> }
> 
