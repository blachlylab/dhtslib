4c4
<     Copyright (C) 2008, 2009, 2013-2020 Genome Research Ltd.
---
>     Copyright (C) 2008, 2009, 2013-2019 Genome Research Ltd.
27,28c27,34
< import core.stdc.stddef;
< import core.stdc.stdlib;
---
> module htslib.sam;
> 
> import core.stdc.stdint;
> import htslib.hts;
> import htslib.hts_log;
> import htslib.bgzf: BGZF;
> import htslib.kstring: kstring_t;
> import std.format: format;
309c315
< extern (D) auto bam_get_cigar(T)(auto ref T b)
---
> extern (D) auto bam_get_cigar(bam1_t * b)
311c317
<     return cast(uint*) b.data + b.core.l_qname;
---
>     return cast(uint*) ((*b).data + (*b).core.l_qname);
370,376d375
< /*!
<  @abstract  Modifies a single base in the bam structure.
<  @param s   Query sequence returned by bam_get_seq()
<  @param i   The i-th position, 0-based
<  @param b   Base in nt16 nomenclature (see seq_nt16_table)
< */
< 
395c394
< sam_hdr_t* sam_hdr_init ();
---
> sam_hdr_t* sam_hdr_init();
408c407
< sam_hdr_t* bam_hdr_read (BGZF* fp);
---
> sam_hdr_t* bam_hdr_read(BGZF* fp);
419c418
< int bam_hdr_write (BGZF* fp, const(sam_hdr_t)* h);
---
> int bam_hdr_write(BGZF* fp, const(sam_hdr_t)* h);
424c423
< void sam_hdr_destroy (sam_hdr_t* h);
---
> void sam_hdr_destroy(sam_hdr_t* h);
433c432
< sam_hdr_t* sam_hdr_dup (const(sam_hdr_t)* h0);
---
> sam_hdr_t* sam_hdr_dup(const(sam_hdr_t)* h0);
438,440c437,441
< sam_hdr_t* bam_hdr_init ();
< void bam_hdr_destroy (sam_hdr_t* h);
< sam_hdr_t* bam_hdr_dup (const(sam_hdr_t)* h0);
---
> pragma(inline,true) 
> sam_hdr_t* bam_hdr_init() { return sam_hdr_init(); }
> 
> pragma(inline,true) 
> void bam_hdr_destroy(sam_hdr_t* h) { sam_hdr_destroy(h); }
442c443,446
< alias samFile = htsFile_;
---
> pragma(inline,true) 
> sam_hdr_t* bam_hdr_dup(const(sam_hdr_t)* h0) { return sam_hdr_dup(h0); }
> 
> alias samFile = htsFile;
455c459
< sam_hdr_t* sam_hdr_parse (size_t l_text, const(char)* text);
---
> sam_hdr_t* sam_hdr_parse(size_t l_text, const(char)* text);
465c469
< sam_hdr_t* sam_hdr_read (samFile* fp);
---
> sam_hdr_t* sam_hdr_read(samFile* fp);
473c477
< int sam_hdr_write (samFile* fp, const(sam_hdr_t)* h);
---
> int sam_hdr_write(samFile* fp, const(sam_hdr_t)* h);
479c483
< size_t sam_hdr_length (sam_hdr_t* h);
---
> size_t sam_hdr_length(sam_hdr_t* h);
491c495
< const(char)* sam_hdr_str (sam_hdr_t* h);
---
> const(char)* sam_hdr_str(sam_hdr_t* h);
497c501
< int sam_hdr_nref (const(sam_hdr_t)* h);
---
> int sam_hdr_nref(const(sam_hdr_t)* h);
514c518
< int sam_hdr_add_lines (sam_hdr_t* h, const(char)* lines, size_t len);
---
> int sam_hdr_add_lines(sam_hdr_t* h, const(char)* lines, size_t len);
529c533
< int sam_hdr_add_line (sam_hdr_t* h, const(char)* type, ...);
---
> int sam_hdr_add_line(sam_hdr_t* h, const(char)* type, ...);
547c551
< int sam_hdr_find_line_id (
---
> int sam_hdr_find_line_id(
568c572
< int sam_hdr_find_line_pos (
---
> int sam_hdr_find_line_pos(
595c599
< int sam_hdr_remove_line_id (
---
> int sam_hdr_remove_line_id(
610c614
< int sam_hdr_remove_line_pos (sam_hdr_t* h, const(char)* type, int position);
---
> int sam_hdr_remove_line_pos(sam_hdr_t* h, const(char)* type, int position);
636c640
< int sam_hdr_update_line (
---
> int sam_hdr_update_line(
656c660
< int sam_hdr_remove_except (
---
> int sam_hdr_remove_except(
699c703
< int sam_hdr_remove_lines (
---
> int sam_hdr_remove_lines(
711c715
< int sam_hdr_count_lines (sam_hdr_t* h, const(char)* type);
---
> int sam_hdr_count_lines(sam_hdr_t* h, const(char)* type);
720c724
< int sam_hdr_line_index (sam_hdr_t* bh, const(char)* type, const(char)* key);
---
> int sam_hdr_line_index(sam_hdr_t* bh, const(char)* type, const(char)* key);
729c733
< const(char)* sam_hdr_line_name (sam_hdr_t* bh, const(char)* type, int pos);
---
> const(char)* sam_hdr_line_name(sam_hdr_t* bh, const(char)* type, int pos);
749c753
< int sam_hdr_find_tag_id (
---
> int sam_hdr_find_tag_id(
772c776
< int sam_hdr_find_tag_pos (
---
> int sam_hdr_find_tag_pos(
787c791
< int sam_hdr_remove_tag_id (
---
> int sam_hdr_remove_tag_id(
804c808
< int sam_hdr_name2tid (sam_hdr_t* h, const(char)* ref_);
---
> int sam_hdr_name2tid(sam_hdr_t* h, const(char)* ref_);
814c818
< const(char)* sam_hdr_tid2name (const(sam_hdr_t)* h, int tid);
---
> const(char)* sam_hdr_tid2name(const(sam_hdr_t)* h, int tid);
824c828
< hts_pos_t sam_hdr_tid2len (const(sam_hdr_t)* h, int tid);
---
> hts_pos_t sam_hdr_tid2len(const(sam_hdr_t)* h, int tid);
833c837,838
< int bam_name2id (sam_hdr_t* h, const(char)* ref_);
---
> pragma(inline,true)
> int bam_name2id(sam_hdr_t* h, const(char)* ref_) { return sam_hdr_name2tid(h, ref_); }
844c849
< const(char)* sam_hdr_pg_id (sam_hdr_t* h, const(char)* name);
---
> const(char)* sam_hdr_pg_id(sam_hdr_t* h, const(char)* name);
861c866
< int sam_hdr_add_pg (sam_hdr_t* h, const(char)* name, ...);
---
> int sam_hdr_add_pg(sam_hdr_t* h, const(char)* name, ...);
872c877
< char* stringify_argv (int argc, char** argv);
---
> char* stringify_argv(int argc, char** argv);
879c884
< void sam_hdr_incr_ref (sam_hdr_t* h);
---
> void sam_hdr_incr_ref(sam_hdr_t* h);
897a903,909
> extern (D) auto sam_hdr_update_hd(T, A...)(auto ref T h, auto ref A a)
> {
>     // NOTE: This macro was dropped by dstep due to variadic args
>     static assert (a.length %2 == 0);   // K-V pairs => even number of variadic args
>     return sam_hdr_update_line(h, "HD", null, null, a, null);
> }
> 
913c925
< bam1_t* bam_init1 ();
---
> bam1_t* bam_init1();
923c935
< void bam_destroy1 (bam1_t* b);
---
> void bam_destroy1(bam1_t* b);
1012c1024,1026
< void bam_set_mempolicy (bam1_t* b, uint policy);
---
> void bam_set_mempolicy(bam1_t* b, uint policy) {
>     b.mempolicy = policy;
> }
1019c1033,1035
< uint bam_get_mempolicy (bam1_t* b);
---
> uint bam_get_mempolicy(bam1_t* b) {
>     return b.mempolicy;
> }
1032c1048
< int bam_read1 (BGZF* fp, bam1_t* b);
---
> int bam_read1(BGZF* fp, bam1_t* b);
1044c1060
< int bam_write1 (BGZF* fp, const(bam1_t)* b);
---
> int bam_write1(BGZF* fp, const(bam1_t)* b);
1052c1068
< bam1_t* bam_copy1 (bam1_t* bdst, const(bam1_t)* bsrc);
---
> bam1_t* bam_copy1(bam1_t* bdst, const(bam1_t)* bsrc);
1062,1102c1078
< bam1_t* bam_dup1 (const(bam1_t)* bsrc);
< 
< /// Sets all components of an alignment structure
< /**
<    @param bam      Target alignment structure. Must be initialized by a call to bam_init1().
<                    The data field will be reallocated automatically as needed.
<    @param l_qname  Length of the query name. If set to 0, the placeholder query name "*" will be used.
<    @param qname    Query name, may be NULL if l_qname = 0
<    @param flag     Bitwise flag, a combination of the BAM_F* constants.
<    @param tid      Chromosome ID, defined by sam_hdr_t (a.k.a. RNAME).
<    @param pos      0-based leftmost coordinate.
<    @param mapq     Mapping quality.
<    @param n_cigar  Number of CIGAR operations.
<    @param cigar    CIGAR data, may be NULL if n_cigar = 0.
<    @param mtid     Chromosome ID of next read in template, defined by sam_hdr_t (a.k.a. RNEXT).
<    @param mpos     0-based leftmost coordinate of next read in template (a.k.a. PNEXT).
<    @param isize    Observed template length ("insert size") (a.k.a. TLEN).
<    @param l_seq    Length of the query sequence (read) and sequence quality string.
<    @param seq      Sequence, may be NULL if l_seq = 0.
<    @param qual     Sequence quality, may be NULL.
<    @param l_aux    Length to be reserved for auxiliary field data, may be 0.
< 
<    @return >= 0 on success (number of bytes written to bam->data), negative (with errno set) on failure.
< */
< int bam_set1 (
<     bam1_t* bam,
<     size_t l_qname,
<     const(char)* qname,
<     ushort flag,
<     int tid,
<     hts_pos_t pos,
<     ubyte mapq,
<     size_t n_cigar,
<     const(uint)* cigar,
<     int mtid,
<     hts_pos_t mpos,
<     hts_pos_t isize,
<     size_t l_seq,
<     const(char)* seq,
<     const(char)* qual,
<     size_t l_aux);
---
> bam1_t* bam_dup1(const(bam1_t)* bsrc);
1124c1100
< hts_pos_t bam_cigar2qlen (int n_cigar, const(uint)* cigar);
---
> hts_pos_t bam_cigar2qlen(int n_cigar, const(uint)* cigar);
1140c1116
< hts_pos_t bam_cigar2rlen (int n_cigar, const(uint)* cigar);
---
> hts_pos_t bam_cigar2rlen(int n_cigar, const(uint)* cigar);
1151,1152c1127
<       string) or a read whose cigar string consumes no reference bases at all,
<       we return b->core.pos + 1 by convention.
---
>       string), we return b->core.pos + 1 by convention.
1154c1129
< hts_pos_t bam_endpos (const(bam1_t)* b);
---
> hts_pos_t bam_endpos(const(bam1_t)* b);
1156c1131
< int bam_str2flag (const(char)* str); /** returns negative value on error */
---
> int bam_str2flag(const(char)* str); /** returns negative value on error */
1158c1133
< char* bam_flag2str (int flag); /** The string must be freed by the user */
---
> char* bam_flag2str(int flag); /** The string must be freed by the user */
1165,1190c1140
< int bam_set_qname (bam1_t* b, const(char)* qname);
< 
< /*! @function
<  @abstract  Parse a CIGAR string into a uint32_t array
<  @param  in      [in]  pointer to the source string
<  @param  end     [out] address of the pointer to the new end of the input string
<                        can be NULL
<  @param  a_cigar [in/out]  address of the destination uint32_t buffer
<  @param  a_mem   [in/out]  address of the allocated number of buffer elements
<  @return         number of processed CIGAR operators; -1 on error
<  */
< ssize_t sam_parse_cigar (
<     const(char)* in_,
<     char** end,
<     uint** a_cigar,
<     size_t* a_mem);
< 
< /*! @function
<  @abstract  Parse a CIGAR string into a bam1_t struct
<  @param  in      [in]  pointer to the source string
<  @param  end     [out] address of the pointer to the new end of the input string
<                        can be NULL
<  @param  b       [in/out]  address of the destination bam1_t struct
<  @return         number of processed CIGAR operators; -1 on error
<  */
< ssize_t bam_parse_cigar (const(char)* in_, char** end, bam1_t* b);
---
> int bam_set_qname(bam1_t* b, const(char)* qname);
1201c1151,1156
< alias bam_itr_next = sam_itr_next;
---
> 
> pragma(inline, true)
> extern (D) auto bam_itr_next(T0, T1, T2)(auto ref T0 htsfp, auto ref T1 itr, auto ref T2 r)
> {
>     return hts_itr_next(htsfp.fp.bgzf, itr, r, 0);
> }
1204a1160
> pragma(inline, true)
1209a1166
> pragma(inline, true)
1226c1183
< int sam_idx_init (htsFile* fp, sam_hdr_t* h, int min_shift, const(char)* fnidx);
---
> int sam_idx_init(htsFile* fp, sam_hdr_t* h, int min_shift, const(char)* fnidx);
1232c1189
< int sam_idx_save (htsFile* fp);
---
> int sam_idx_save(htsFile* fp);
1241c1198
< hts_idx_t* sam_index_load (htsFile* fp, const(char)* fn);
---
> hts_idx_t* sam_index_load(htsFile* fp, const(char)* fn);
1251c1208
< hts_idx_t* sam_index_load2 (htsFile* fp, const(char)* fn, const(char)* fnidx);
---
> hts_idx_t* sam_index_load2(htsFile* fp, const(char)* fn, const(char)* fnidx);
1271c1228
< hts_idx_t* sam_index_load3 (
---
> hts_idx_t* sam_index_load3(
1284c1241
< int sam_index_build (const(char)* fn, int min_shift);
---
> int sam_index_build(const(char)* fn, int min_shift);
1293c1250
< int sam_index_build2 (const(char)* fn, const(char)* fnidx, int min_shift);
---
> int sam_index_build2(const(char)* fn, const(char)* fnidx, int min_shift);
1303c1260
< int sam_index_build3 (
---
> int sam_index_build3(
1330c1287
< hts_itr_t* sam_itr_queryi (
---
> hts_itr_t* sam_itr_queryi(
1358c1315
< hts_itr_t* sam_itr_querys (
---
> hts_itr_t* sam_itr_querys(
1377c1334
< hts_itr_t* sam_itr_regions (
---
> hts_itr_t* sam_itr_regions(
1407c1364
< hts_itr_t* sam_itr_regarray (
---
> hts_itr_t* sam_itr_regarray(
1419c1376,1390
< int sam_itr_next (htsFile* htsfp, hts_itr_t* itr, bam1_t* r);
---
> int sam_itr_next(htsFile* htsfp, hts_itr_t* itr, bam1_t* r) {
>     if (!htsfp.is_bgzf && !htsfp.is_cram) {
>         hts_log_error(__FUNCTION__, format("%s not BGZF compressed", htsfp.fn ? htsfp.fn : "File"));
>         return -2;
>     }
>     if (!itr) {
>         hts_log_error(__FUNCTION__,"Null iterator");
>         return -2;
>     }
> 
>     if (itr.multi)
>         return hts_itr_multi_next(htsfp, itr, r);
>     else
>         return hts_itr_next(htsfp.is_bgzf ? htsfp.fp.bgzf : null, itr, r, htsfp);
> }
1429c1400
< const(char)* sam_parse_region (
---
> const(char)* sam_parse_region(
1441,1450c1412,1413
< extern (D) auto sam_open(T0, T1)(auto ref T0 fn, auto ref T1 mode)
< {
<     return hts_open(fn, mode);
< }
< 
< extern (D) auto sam_open_format(T0, T1, T2)(auto ref T0 fn, auto ref T1 mode, auto ref T2 fmt)
< {
<     return hts_open_format(fn, mode, fmt);
< }
< 
---
> alias sam_open = hts_open;
> alias sam_open_format = hts_open_format;
1453c1416
< int sam_open_mode (char* mode, const(char)* fn, const(char)* format);
---
> int sam_open_mode(char* mode, const(char)* fn, const(char)* format);
1458c1421
< char* sam_open_mode_opts (
---
> char* sam_open_mode_opts(
1463c1426
< int sam_hdr_change_HD (sam_hdr_t* h, const(char)* key, const(char)* val);
---
> int sam_hdr_change_HD(sam_hdr_t* h, const(char)* key, const(char)* val);
1465,1466c1428,1429
< int sam_parse1 (kstring_t* s, sam_hdr_t* h, bam1_t* b);
< int sam_format1 (const(sam_hdr_t)* h, const(bam1_t)* b, kstring_t* str);
---
> int sam_parse1(kstring_t* s, sam_hdr_t* h, bam1_t* b);
> int sam_format1(const(sam_hdr_t)* h, const(bam1_t)* b, kstring_t* str);
1474c1437
< int sam_read1 (samFile* fp, sam_hdr_t* h, bam1_t* b);
---
> int sam_read1(samFile* fp, sam_hdr_t* h, bam1_t* b);
1481,1495c1444
< int sam_write1 (samFile* fp, const(sam_hdr_t)* h, const(bam1_t)* b);
< 
< // Forward declaration, see hts_expr.h for full.
< struct hts_filter_t;
< 
< /// sam_passes_filter - Checks whether a record passes an hts_filter.
< /** @param h      Pointer to the header structure previously read
<  *  @param b      Pointer to the BAM record to be checked
<  *  @param filt   Pointer to the filter, created from hts_filter_init.
<  *  @return       1 if passes, 0 if not, and <0 on error.
<  */
< int sam_passes_filter (
<     const(sam_hdr_t)* h,
<     const(bam1_t)* b,
<     hts_filter_t* filt);
---
> int sam_write1(samFile* fp, const(sam_hdr_t)* h, const(bam1_t)* b);
1501,1541d1449
< /// Converts a BAM aux tag to SAM format
< /*
<  * @param b    Pointer to the bam record
<  * @param key  Two letter tag key
<  * @param type Single letter type code: ACcSsIifHZB.
<  * @param tag  Tag data pointer, in BAM format
<  * @param end  Pointer to end of bam record (largest extent of tag)
<  * @param ks   Kstring to write the formatted tag to
<  *
<  * @return pointer to end of tag on success,
<  *         NULL on failure.
<  *
<  * @discussion The three separate parameters key, type, tag may be
<  * derived from a s=bam_aux_get() query as s-2, *s and s+1.  However
<  * it is recommended to use bam_aux_get_str in this situation.
<  * The desire to split these parameters up is for potential processing
<  * of non-BAM formats that encode using a BAM type mechanism
<  * (such as the internal CRAM representation).
<  */
< 
< // brevity and consistency with other code.
< 
< // NB: "d" is not an official type in the SAM spec.
< // However for unknown reasons samtools has always supported this.
< // We believe, HOPE, it is not in general usage and we do not
< // encourage it.
< 
< // or externalise sam.c's aux_type2size function?
< 
< // now points to the start of the array
< 
< // write the type
< 
< // Unknown type
< const(ubyte)* sam_format_aux1 (
<     const(ubyte)* key,
<     const ubyte type,
<     const(ubyte)* tag,
<     const(ubyte)* end,
<     kstring_t* ks);
< 
1551,1562c1459
< ubyte* bam_aux_get (const(bam1_t)* b, ref const(char)[2] tag);
< 
< /// Return a SAM formatting string containing a BAM tag
< /** @param b   Pointer to the bam record
<     @param tag Desired aux tag
<     @param s   The kstring to write to.
< 
<     @return 1 on success,
<             0 on no tag found with errno = ENOENT,
<            -1 on error (errno will be either EINVAL or ENOMEM).
<  */
< int bam_aux_get_str (const(bam1_t)* b, ref const(char)[2] tag, kstring_t* s);
---
> ubyte* bam_aux_get(const(bam1_t)* b, ref const(char)[2] tag);
1570c1467
< long bam_aux2i (const(ubyte)* s);
---
> long bam_aux2i(const(ubyte)* s);
1578c1475
< double bam_aux2f (const(ubyte)* s);
---
> double bam_aux2f(const(ubyte)* s);
1585c1482
< char bam_aux2A (const(ubyte)* s);
---
> char bam_aux2A(const(ubyte)* s);
1592c1489
< char* bam_aux2Z (const(ubyte)* s);
---
> char* bam_aux2Z(const(ubyte)* s);
1599c1496
< uint bam_auxB_len (const(ubyte)* s);
---
> uint bam_auxB_len(const(ubyte)* s);
1609c1506
< long bam_auxB2i (const(ubyte)* s, uint idx);
---
> long bam_auxB2i(const(ubyte)* s, uint idx);
1620c1517
< double bam_auxB2f (const(ubyte)* s, uint idx);
---
> double bam_auxB2f(const(ubyte)* s, uint idx);
1633c1530
< int bam_aux_append (
---
> int bam_aux_append(
1647c1544
< int bam_aux_del (bam1_t* b, ubyte* s);
---
> int bam_aux_del(bam1_t* b, ubyte* s);
1658,1666d1554
<    If @p len is less than zero, the length of the input string will be
<    calculated using strlen().  Otherwise exactly @p len bytes will be
<    copied from @p data to make the new tag.  If these bytes do not
<    include a terminating NUL character, one will be added.  (Note that
<    versions of HTSlib up to 1.10.2 had different behaviour here and
<    simply copied @p len bytes from data.  To generate a valid tag it
<    was necessary to ensure the last character was a NUL, and include
<    it in @p len.)
< 
1676c1564
< int bam_aux_update_str (
---
> int bam_aux_update_str(
1703c1591
< int bam_aux_update_int (bam1_t* b, ref const(char)[2] tag, long val);
---
> int bam_aux_update_int(bam1_t* b, ref const(char)[2] tag, long val);
1722c1610
< int bam_aux_update_float (bam1_t* b, ref const(char)[2] tag, float val);
---
> int bam_aux_update_float(bam1_t* b, ref const(char)[2] tag, float val);
1745c1633
<    will grow or shrink in order to accommodate the new data.
---
>    will grow or shrink in order to accomodate the new data.
1760c1648
< int bam_aux_update_array (
---
> int bam_aux_update_array(
1828c1716
< alias bam_plp_auto_f = int function (void* data, bam1_t* b);
---
> alias bam_plp_auto_f = int function(void* data, bam1_t* b);
1830,1831c1718,1719
< struct bam_plp_s;
< alias bam_plp_t = bam_plp_s*;
---
> struct __bam_plp_t;
> alias bam_plp_t = __bam_plp_t*;
1833,1834c1721,1722
< struct bam_mplp_s;
< alias bam_mplp_t = bam_mplp_s*;
---
> struct __bam_mplp_t;
> alias bam_mplp_t = __bam_mplp_t*;
1845c1733
< bam_plp_t bam_plp_init (bam_plp_auto_f func, void* data);
---
> bam_plp_t bam_plp_init(bam_plp_auto_f func, void* data);
1847c1735
< void bam_plp_destroy (bam_plp_t iter);
---
> void bam_plp_destroy(bam_plp_t iter);
1849c1737
< int bam_plp_push (bam_plp_t iter, const(bam1_t)* b);
---
> int bam_plp_push(bam_plp_t iter, const(bam1_t)* b);
1851c1739
< const(bam_pileup1_t)* bam_plp_next (
---
> const(bam_pileup1_t)* bam_plp_next(
1857c1745
< const(bam_pileup1_t)* bam_plp_auto (
---
> const(bam_pileup1_t)* bam_plp_auto(
1863c1751
< const(bam_pileup1_t)* bam_plp64_next (
---
> const(bam_pileup1_t)* bam_plp64_next(
1869c1757
< const(bam_pileup1_t)* bam_plp64_auto (
---
> const(bam_pileup1_t)* bam_plp64_auto(
1875c1763
< void bam_plp_set_maxcnt (bam_plp_t iter, int maxcnt);
---
> void bam_plp_set_maxcnt(bam_plp_t iter, int maxcnt);
1877c1765
< void bam_plp_reset (bam_plp_t iter);
---
> void bam_plp_reset(bam_plp_t iter);
1887c1775
< void bam_plp_constructor (
---
> void bam_plp_constructor(
1889,1890c1777,1778
<     int function (void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
< void bam_plp_destructor (
---
>     int function(void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
> void bam_plp_destructor(
1892c1780
<     int function (void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
---
>     int function(void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
1907c1795
< int bam_plp_insertion (const(bam_pileup1_t)* p, kstring_t* ins, int* del_len);
---
> int bam_plp_insertion(const(bam_pileup1_t)* p, kstring_t* ins, int* del_len);
1913c1801
< bam_mplp_t bam_mplp_init (int n, bam_plp_auto_f func, void** data);
---
> bam_mplp_t bam_mplp_init(int n, bam_plp_auto_f func, void** data);
1927c1815
< int bam_mplp_init_overlaps (bam_mplp_t iter);
---
> int bam_mplp_init_overlaps(bam_mplp_t iter);
1929c1817
< void bam_mplp_destroy (bam_mplp_t iter);
---
> void bam_mplp_destroy(bam_mplp_t iter);
1931c1819
< void bam_mplp_set_maxcnt (bam_mplp_t iter, int maxcnt);
---
> void bam_mplp_set_maxcnt(bam_mplp_t iter, int maxcnt);
1933c1821
< int bam_mplp_auto (
---
> int bam_mplp_auto(
1940c1828
< int bam_mplp64_auto (
---
> int bam_mplp64_auto(
1947c1835
< void bam_mplp_reset (bam_mplp_t iter);
---
> void bam_mplp_reset(bam_mplp_t iter);
1949c1837
< void bam_mplp_constructor (
---
> void bam_mplp_constructor(
1951c1839
<     int function (void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
---
>     int function(void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
1953c1841
< void bam_mplp_destructor (
---
> void bam_mplp_destructor(
1955c1843
<     int function (void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
---
>     int function(void* data, const(bam1_t)* b, bam_pileup_cd* cd) func);
1963c1851
< int sam_cap_mapq (bam1_t* b, const(char)* ref_, hts_pos_t ref_len, int thres);
---
> int sam_cap_mapq(bam1_t* b, const(char)* ref_, hts_pos_t ref_len, int thres);
2005c1893
< int sam_prob_realn (bam1_t* b, const(char)* ref_, hts_pos_t ref_len, int flag);
---
> int sam_prob_realn(bam1_t* b, const(char)* ref_, hts_pos_t ref_len, int flag);
